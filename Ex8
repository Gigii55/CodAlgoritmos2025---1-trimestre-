package ExerciciosAPS;

import java.util.Arrays;
import java.util.Random;

public class Ex8 {

    public static void main(String[] args) {

        Random random = new Random();
        int sorteio = random.nextInt(3);

        int[] vetor;

        if (sorteio == 1) {
            System.out.println("Vetor sorteado: ALEATÓRIO");
            vetor = geraVetAleatorio();

        } else if (sorteio == 2) {
            System.out.println("Vetor sorteado: ORDENADO");
            vetor = geraVetOrdenado();

        } else {
            System.out.println("Vetor sorteado: INVERTIDO");
            vetor = geraVetInvertido();
        }

        long inicioBolha = System.nanoTime();
        ordenaBubble(vetor);
      
        long fimBolha = System.nanoTime();
        long tempoBolha = fimBolha - inicioBolha;
        System.out.println("BOLHA - Tempo de execução: " + tempoBolha  * Math.pow(10,-9)+ " ns");
 
        long inicioSelect = System.nanoTime();
        ordenaSelection(vetor);
        long fimSelect = System.nanoTime();
        long tempoSelect = fimSelect - inicioSelect;
        System.out.println("SELECTION - Tempo de execução: " + tempoSelect* Math.pow(10,-9) + " ns");

        long inicioInsert = System.nanoTime();
        ordenaInsert(vetor);
        long fimInsert = System.nanoTime();
        long tempoInsert = fimInsert - inicioInsert;
        System.out.println("INSERTION - Tempo de execução: " + tempoInsert * Math.pow(10,-9) + " ns");

        long inicioMerge = System.nanoTime();
        mergeSort(vetor,0,vetor.length-1);
        long fimMerge = System.nanoTime();
        long tempoMerge = fimMerge - inicioMerge;
        System.out.println("MERGE - Tempo de execução: " + tempoMerge * Math.pow(10,-9)+ " ns");
      
        if (tempoBolha < tempoSelect && tempoBolha < tempoInsert) {
            System.out.println("Algoritmo mais rápido: BOLHA com " + tempoBolha * Math.pow(10,-9) + " ns");
        } else if (tempoSelect < tempoBolha && tempoSelect < tempoInsert) {
            System.out.println("Algoritmo mais rápido: SELECTION com " + tempoSelect * Math.pow(10,-9)+ " ns");
        } else {
            System.out.println("Algoritmo mais rápido: INSERTION com " + tempoInsert * Math.pow(10,-9)+ " ns");
        }

    }

    public static int[] geraVetAleatorio() {
    	
        int[] vetor = new int[100000];
        
        Random ale = new Random();
        
        for (int i = 0; i < vetor.length; i++) {
        	
            vetor[i] = ale.nextInt(100);
        }
        return vetor;
    }

    public static int[] geraVetOrdenado() {
    	
        int[] vetor = geraVetAleatorio();
        Arrays.sort(vetor);
        return vetor;
    }

    public static int[] geraVetInvertido() {
    	
        int[] vet = geraVetOrdenado();
        
        int tam = vet.length;
        
        for (int i = 0; i < tam - 1; i++) {
        	
            for (int j = 0; j < tam - 1 - i; j++) {
                if (vet[j] < vet[j + 1]) {
                    int aux = vet[j];
                    vet[j] = vet[j + 1];
                    vet[j + 1] = aux;
                }
            }
        }
        
        return vet;
        
        }
    
    public static void mergeSort(int[] vetor, int inicio, int fim) {
        if (inicio < fim) {
            int meio = (inicio + fim) / 2;
            mergeSort(vetor, inicio, meio);
            mergeSort(vetor, meio + 1, fim);
            ordenaMerge(vetor, inicio, meio, fim);
        }
    }
    private static void ordenaMerge(int[] vetor, int inicio, int meio, int fim) {
		int n1 = meio - inicio + 1;
		int n2 = fim - meio;

		int[] L = new int[n1];
		int[] R = new int[n2];

		for (int i = 0; i < n1; i++) {
			L[i] = vetor[inicio + i];
		}
		for (int j = 0; j < n2; j++) {
			R[j] = vetor[meio + 1 + j];
		}

		int i = 0, j = 0;
		int k = inicio;

		while (i < n1 && j < n2) {
			if (L[i] <= R[j]) {
				vetor[k] = L[i];
				i++;
			} else {
				vetor[k] = R[j];
				j++;
			}
			k++;
		}

		while (i < n1) {
			vetor[k] = L[i];
			i++;
			k++;
		}

		while (j < n2) {
			vetor[k] = R[j];
			j++;
			k++;
		}
	}
    public static void ordenaBubble(int[] vet) {
        int tam = vet.length;
        for (int i = 0; i < tam - 1; i++) {
            for (int j = 0; j < tam - 1 - i; j++) {
                if (vet[j] > vet[j + 1]) {
                    int aux = vet[j];
                    vet[j] = vet[j + 1];
                    vet[j + 1] = aux;
                }
            }
        }
    }

    public static void ordenaSelection(int[] vet) {
        int tam = vet.length;
        for (int i = 0; i < tam - 1; i++) {
            int menor = i;
            for (int j = i + 1; j < tam; j++) {
                if (vet[j] < vet[menor]) {
                    menor = j;
                }
            }
            int temp = vet[menor];
            vet[menor] = vet[i];
            vet[i] = temp;
        }
    }

    public static void ordenaInsert(int[] vet) {
        for (int i = 1; i < vet.length; i++) {
            int key = vet[i];
            int j = i - 1;
            while (j >= 0 && vet[j] > key) {
                vet[j + 1] = vet[j];
                j--;
            }
            vet[j + 1] = key;
        }
    }


   

    
  
}
